import random
import sys

import requests
import textwrap
from bs4 import BeautifulSoup
from typing import Dict, List

sys.path.insert(0, '..')
import keys


def _get_next_key() -> Dict[str, str]:
    """
    Get next authentication key for authenticating with pastebin.  
    """

    nxt = keys.PASTEBIN_KEYS.pop(0)
    keys.PASTEBIN_KEYS.append(nxt)

    return nxt


def _wrap_data_with_information(data: str, paste_url: str) -> str:
    """
    Just adds an "information line" to the botton of the paste content
    identifying from where said paste information came from.

    data - the data we want to wrap
    paste_url - the URL from which this data came from

    returns the wrapped data
    """
    
    return data + textwrap.dedent(f"""

    This data can also be found in pastebin, at the following URL: {paste_url}""")


def add_paste(new_text: str) -> str:
    """
    Adds a new paste to pastebin

    new_text - the text to add to pastebin

    returns the URL where the text now lives
    """

    # Here we generate a name for the new paste 
    new_text = "This dump was generated by 'PopularTorrentBot'\n\n" + new_text

    possible = list(
        "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789")

    random.shuffle(possible)

    paste_name = "TTD ID: " + "".join(possible[:4])

    
    def try_actual_bin_creation(api_key: Dict[str, str]) -> List:
        """
        This function is the one that attempts to add the content to pastebin
        The content is taken from the parameter passed to the parent function
        (new_text).

        api_key - is a dict with keys "api_dev_key" and "api_user_key". These
                  are used to authenticate with pastebin.

        returns a List of 2 elements, where the first indicates if the operation
            was successful or not. And the second indicates either the error
            message (in case of an unsuccessful operation) or the new URL
            where the paste was created
        """

        payload = {
            **api_key,
            "api_option": 'paste',
            "api_paste_code": new_text,
            "api_paste_private": '0',
            "api_paste_name": paste_name,
            "api_paste_expire_date": '6M',
        }

        url = "https://pastebin.com/api/api_post.php"
        response = requests.request("POST", url, data=payload)

        if not response.text.startswith("http"):
            print(response.text)
            return False, "There was some sort of error in pastebin: " + response.text

        else:
            # everything went well, return URL
            return True, response.text

    # here we try to add a new paste, we try once for every key in our keys array
    # and stop when we finish the keys or when the operation is successful 
    succeeded = (False,)
    i = 0
    while not succeeded[0] and i <= len(keys.PASTEBIN_KEYS):
        succeeded = try_actual_bin_creation(_get_next_key())
        i += 1

    # if we weren't successful at all then raise an error so we're aware of it 
    if not succeeded[0]:
        raise RuntimeError(succeeded[1])

    else:
        # the paste URL returned by pastebin is to the HTML version of the paste
        # we want to save the URL to the RAW version (which is easier to process and to see) 
        paste_id = succeeded[1].split("/")[-1]
        return "https://pastebin.com/raw/" + paste_id


def get_paste(paste_url: str, wrap=True) -> str: 
    """
    Gets the content that is associated with a specific pastebin url

    paste_url - the URL from which we want to get the content from
    wrap (default True) - if we want to add the line at the botton of the paste
    which identifies where the paste came from

    returns the content in the pastebin_url
    """

    # first we request the URL
    paste = requests.request("GET", paste_url).text

    # sometimes, especially when the content had previously been marked as spam, pastibin will not return
    # the RAW version of the paste, but will instead return the HTML version. In this case we need to 
    # process the content with BeautifulSoup and exctract the content from the appropiate element 
    if paste.startswith("<!DOCTYPE HTML>") and "Your paste has triggered our automatic SPAM" not in paste:
        parsed_html = BeautifulSoup(paste, features="html.parser")
        paste = parsed_html.body.find(
            'textarea', attrs={'id': 'paste_code'}).text

    # To every new paste created in pastebin we add a line at the top specifying that 
    # "PopularTorrentBot" was the creator of the content. This line must be removed
    # before returning the content 
    if paste.startswith("This dump was generated by 'PopularTorrentBot'"):
        text_to_break = "This dump was generated by 'PopularTorrentBot'\n\n"
        found_at_index = paste.index(text_to_break)
        paste = paste[found_at_index + len(text_to_break):]


    if wrap:
        return _wrap_data_with_information(paste, paste_url)

    else:
        return paste
